import face_recognition
import cv2
import numpy as np
import csv
from datetime import datetime
import os
from PIL import Image # Used for initial image verification checks, but face_recognition.load_image_file for encoding

# Get the directory of the current script.
# This ensures all relative paths work correctly no matter how the script is run.
script_dir = os.path.dirname(os.path.abspath(__file__))

# --------- Initial Image File Verification (Optional but good for debugging) --------- #
print("üîç Verifying initial face image files:")
# This block checks for the existence and basic loadability of original PNG files.
# It's primarily for confirming file paths and basic PIL functionality,
# not directly for face encoding.
for name in ["monu.png", "rohan.png"]: # Adjust these if your initial image names are different
    full_path_check = os.path.join(script_dir, name)
    try:
        img_check = Image.open(full_path_check).convert("RGB")
        arr_check = np.array(img_check)
        print(f"‚úÖ {name} loaded successfully for initial check ‚Äî shape={arr_check.shape}, dtype={arr_check.dtype}")
    except FileNotFoundError:
        print(f"‚ÑπÔ∏è File not found for initial check: {name} at {full_path_check}")
    except Exception as e:
        print(f"‚ùå Error loading {name} for initial check: {e}")

# --------- Helper Function: Load and Encode Known Faces --------- #
def load_face_encoding(image_path_relative):
    """
    Loads an image, finds faces within it, and returns the encoding of the first face found.
    Uses face_recognition's built-in image loading for best compatibility.
    """
    full_path = os.path.join(script_dir, image_path_relative)
    try:
        if not os.path.exists(full_path):
            print(f"‚ùå Error: Image file not found at expected path: {full_path}")
            return None

        # face_recognition.load_image_file is the most robust way to load images
        # for this library, handling various formats and preparing them for dlib.
        image = face_recognition.load_image_file(full_path)

        # Get face encodings from the loaded image
        encodings = face_recognition.face_encodings(image)

        if not encodings:
            print(f"‚ùå No face found in {image_path_relative} at {full_path}. "
                  "Please ensure the image clearly shows a single face.")
            return None
        
        print(f"‚úÖ Successfully loaded and encoded face from: {image_path_relative}")
        return encodings[0] # Return the first face found
        
    except Exception as e:
        print(f"‚ùå An error occurred while processing {image_path_relative}: {e}")
        return None

# --------- Define People and Their Reprocessed Image Files --------- #
# These should point to the reprocessed images generated by image_converter.py
# Make sure these filenames EXACTLY match the files in your script_dir.
people_to_recognize = {
    "monu": "monu_fixed_reprocessed.jpg",
    "rohan": "rohan_fixed_reprocessed.jpg"
}

# --------- Load and Encode Known Faces for Recognition --------- #
known_face_encodings = []
known_face_names = []

print("\nüöÄ Loading known faces for recognition:")
for name, img_file in people_to_recognize.items():
    encoding = load_face_encoding(img_file)
    if encoding is not None:
        known_face_encodings.append(encoding)
        known_face_names.append(name)

# Exit if no known faces could be loaded, as the system can't function then.
if not known_face_encodings:
    print("‚ùå Critical Error: No known faces could be loaded. Exiting the program.")
    exit()
else:
    print(f"‚úÖ Successfully loaded {len(known_face_names)} known faces: {', '.join(known_face_names)}")

# This list keeps track of students already marked present for the current session.
students_marked_today = known_face_names.copy()

# --------- Prepare Attendance CSV File --------- #
now = datetime.now()
current_date_str = now.strftime("%Y-%m-%d")
csv_file_path = os.path.join(script_dir, f"attendance_{current_date_str}.csv")

try:
    # Open CSV in append mode, create if it doesn't exist
    # Ensure newline="" to prevent extra blank rows
    f_csv = open(csv_file_path, "a", newline="") 
    csv_writer = csv.writer(f_csv)

    # Write header only if the file is new/empty (check size == 0)
    if os.path.getsize(csv_file_path) == 0:
        csv_writer.writerow(["Name", "Time"])
        print(f"\nüìÅ Created new attendance file: {csv_file_path}")
    else:
        print(f"\nüìÅ Appending to existing attendance file: {csv_file_path}")

except Exception as e:
    print(f"‚ùå Error setting up CSV file: {e}")
    print("Exiting program as attendance cannot be recorded.")
    exit()

# --------- Start Webcam for Real-time Face Recognition --------- #
print("\nüé• Starting webcam...")
video_capture = cv2.VideoCapture(0) # 0 is typically the default webcam

if not video_capture.isOpened():
    print("‚ùå Error: Could not open webcam. Please check if webcam is connected and drivers are installed.")
    print("Exiting program.")
    f_csv.close() # Close CSV file before exiting
    exit()

print("Press 'q' to quit the attendance system.")

while True:
    ret, frame = video_capture.read()

    if not ret:
        print("‚ùå Failed to grab frame from webcam. Attempting to re-initialize...")
        video_capture.release() # Release current handle
        video_capture = cv2.VideoCapture(0) # Try to re-open
        if not video_capture.isOpened():
            print("‚ùå Critical: Webcam re-initialization failed. Exiting.")
            break # Exit the loop if camera cannot be restored
        cv2.waitKey(500) # Wait a bit before next read
        continue

    # Resize frame for faster processing (1/4th size)
    small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)
    
    # Convert the image from BGR color (which OpenCV uses) to RGB color (which face_recognition uses)
    rgb_small_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)

    # Find all the faces and face encodings in the current frame of video
    face_locations = face_recognition.face_locations(rgb_small_frame)
    face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)

    for face_encoding, face_location in zip(face_encodings, face_locations):
        # Compare current face with known faces
        matches = face_recognition.compare_faces(known_face_encodings, face_encoding)
        face_distances = face_recognition.face_distance(known_face_encodings, face_encoding)
        best_match_index = np.argmin(face_distances)

        name = "Unknown"
        # If a match is found, use the known name
        if matches[best_match_index]:
            name = known_face_names[best_match_index]

            # Mark attendance if the person hasn't been marked yet for this session
            if name in students_marked_today:
                current_time_str = datetime.now().strftime("%H:%M:%S")
                csv_writer.writerow([name, current_time_str])
                students_marked_today.remove(name) # Remove from list to avoid duplicate marking
                print(f"üü¢ Marked present: {name} at {current_time_str}")

        # Draw a box around the face
        # Scale back up the face locations since we detected on a scaled-down image
        top, right, bottom, left = [v * 4 for v in face_location]
        cv2.rectangle(frame, (left, top), (right, bottom), (0, 255, 0), 2)

        # Draw a label with a name below the face
        cv2.putText(frame, name, (left, top - 10), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)

    # Display the resulting image
    cv2.imshow("Attendance System - Press 'q' to Quit", frame)

    # Break the loop if 'q' is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# --------- Cleanup Operations --------- #
print("\n--- Cleaning up resources ---")
video_capture.release() # Release the webcam
cv2.destroyAllWindows() # Close all OpenCV windows
f_csv.close() # Close the CSV file
print("üìÅ Attendance saved and program closed.")